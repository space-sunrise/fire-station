// Шейдер для создания нестабильного портала/разлома в реальности
// Эффект включает пульсацию, искажения, разъезжание на кусочки, сборку и ИНТЕНСИВНОЕ МЕРЦАНИЕ

uniform sampler2D SCREEN_TEXTURE;

void fragment() {
    highp vec2 uv = FRAGCOORD.xy * SCREEN_PIXEL_SIZE;

    // Получаем маску формы портала из текущего спрайта
    highp vec4 tex_color = texture(TEXTURE, UV);
    highp float portal_mask = tex_color.a;

    // Если текущий пиксель не входит в область портала, делаем его прозрачным
    if (portal_mask < 1) {
        COLOR = vec4(0.0, 0.0, 0.0, 0.0);
        return;
    }

    // Временные параметры для создания различных циклов анимации
    highp float time1 = TIME * 2.0;
    highp float time2 = TIME * 0.5;
    highp float time3 = TIME * 0.23;
    highp float time4 = TIME * 3.7;

    // Вычисляем градиент от центра
    highp vec2 centered_uv = UV * 2.0 - 1.0;
    highp float distance_from_center = length(centered_uv);

    // --- Эффект разъезжания и сборки ---
    // Параметры эффекта (константы)
    const float CUT_COUNT = 7.0;
    const float CUT_WIDTH = 0.02;
    const float DISPERSION_FACTOR = 0.2;
    const float ASSEMBLY_SPEED = 1.0;

    // Прогресс анимации от 0 (собран) до 1 (разобран) и обратно
    highp float anim_progress = abs(sin(TIME * ASSEMBLY_SPEED));

    // Создаем эффект горизонтальных "разрезов"
    highp float cut_lines = 0.0;
    for (float i = 0.0; i < CUT_COUNT; i++) {
        float cut_pos = (i + 0.5) / CUT_COUNT;
        float cut_offset = sin(cut_pos * 10.0 + time1) * 0.005 * anim_progress;
        float cut_line = smoothstep(cut_pos - CUT_WIDTH * 0.5 + cut_offset, cut_pos + CUT_WIDTH * 0.5 + cut_offset, fract(uv.y * CUT_COUNT));
        cut_lines += cut_line;
    }
    cut_lines = clamp(cut_lines, 0.0, 1.0);

    // Эффект разъезжания слоев - смещение UV координат РАДИАЛЬНО от центра
    highp vec2 dispersed_uv = uv;
    float layer_index = floor(uv.y * CUT_COUNT);
    highp float layer_dispersion = DISPERSION_FACTOR * anim_progress;
    dispersed_uv += centered_uv * layer_dispersion;

    // Комбинируем исходные UV и смещенные UV в зависимости от прогресса анимации
    highp vec2 final_uv = mix(dispersed_uv, uv, 1.0 - anim_progress);

    // --- Остальные эффекты портала (пульсация, искажение, свечение) ---

    // Пульсирующая нестабильная форма портала
    highp float form_distortion =
        sin(distance_from_center * 8.0 + time1) * 0.06 +
        cos(distance_from_center * 5.0 - time2) * 0.04 +
        sin(centered_uv.x * 6.0 + centered_uv.y * 4.0 + time3) * 0.05;

    // Применяем искажение к форме портала
    highp float distorted_mask = smoothstep(0.0, 0.2, portal_mask + form_distortion);

    // "Дышащий" эффект пульсации
    highp float base_intensity = 0.05;
    highp float pulse_intensity =
        base_intensity * (1.0 + 0.6 * sin(time2)) +
        0.02 * sin(time1 * 1.5) +
        0.01 * sin(time3 * 3.0 + distance_from_center * 2.0);

    // **УСИЛЕННЫЙ ЭФФЕКТ "СБОЕВ" ПОРТАЛА (МЕРЦАНИЕ)**
    // Уменьшаем порог step для более частых срабатываний (с 0.97 до 0.8)
    // Увеличиваем интенсивность эффекта (умножение на 0.2 вместо 0.1)
    // Увеличиваем частоту быстрого синуса (30.0 до 60.0)
    highp float glitch_effect = step(0.8, sin(time4 * 0.5) * 0.5 + 0.5) * sin(time4 * 60.0) * 0.2;

    highp float distortion_intensity = pulse_intensity + glitch_effect;

    // Волнообразное искажение
    highp float angle = atan(centered_uv.y, centered_uv.x);
    highp float wave1 = sin(time1 + distance_from_center * 4.0 + angle * 2.0) * distortion_intensity;
    highp float wave2 = cos(time2 * 0.7 + distance_from_center * 3.0 - angle) * distortion_intensity * 0.8;
    highp float wave3 = sin(time3 * 2.0 + distance_from_center * 7.0) * distortion_intensity * 0.5;

    highp float edge_factor = smoothstep(0.0, 1.0, distance_from_center);
    highp vec2 warped_uv = final_uv;
    warped_uv += vec2(wave1 + wave3, wave2) * edge_factor;

    // "Рванные края"
    highp float tear_effect = sin(angle * 5.0 + time1) * sin(time2 * 2.0) * 0.01;
    warped_uv += tear_effect * vec2(cos(angle), sin(angle)) * edge_factor;

    // Хроматическая аберрация
    highp float aberration_base = 0.003;
    highp float aberration_pulse = aberration_base * (1.0 + sin(time2) * 0.5) * (1.0 + edge_factor * 2.0);
    highp vec3 col;
    col.r = texture(SCREEN_TEXTURE, warped_uv + vec2(aberration_pulse, 0.0)).r;
    col.g = texture(SCREEN_TEXTURE, warped_uv).g;
    col.b = texture(SCREEN_TEXTURE, warped_uv - vec2(aberration_pulse, aberration_pulse * 0.5)).b;

    // Пульсирующее свечение портала
    highp vec3 glow_color = vec3(0.3, 0.4, 0.9);
    highp vec3 glow_shift = vec3(
        sin(time2) * 0.2,
        sin(time2 + 2.0) * 0.3,
        sin(time2 + 4.0) * 0.1
    );
    highp vec3 final_glow = glow_color + glow_shift;
    highp float glow_intensity = 0.6 + 0.4 * sin(time1 * 0.3) + 0.2 * sin(time3 * 2.0);
    col += final_glow * edge_factor * glow_intensity;

    // Энергетические разряды
    highp float discharge =
        step(0.7, sin(angle * 12.0 + time4) * 0.5 + 0.5) *
        step(0.8, sin(time1 * 2.0) * 0.5 + 0.5) *
        edge_factor * 0.3;
    col += vec3(0.8, 0.9, 1.0) * discharge;

    // Динамический шум
    highp float noise_time = time4 * 0.2;
    highp float noise = fract(sin(dot(warped_uv + noise_time, vec2(12.9898, 78.233))) * 43758.5453);
    highp float noise_intensity = 0.03 + 0.02 * sin(time2);
    col += (noise - 0.5) * noise_intensity * vec3(1.0, 1.0, 1.2);

    // Эффект "размытия" реальности
    highp float reality_blur = smoothstep(0.4, 0.9, edge_factor);
    col = mix(col, col * (1.0 + glow_intensity * 0.3), reality_blur);

    // Финальный цвет с использованием искаженной маски портала
    COLOR = vec4(col, distorted_mask);
}
