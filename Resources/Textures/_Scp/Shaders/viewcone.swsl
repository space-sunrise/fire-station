uniform sampler2D BLURRED_TEXTURE;
uniform mediump float coneOpacity;

uniform sampler2D SCREEN_TEXTURE;
uniform highp float Zoom;
uniform highp float ConeAngle;
uniform highp float ConeFeather;
uniform highp float ConeIgnoreRadius;
uniform highp float ConeIgnoreFeather;
uniform highp float ViewAngle;

void fragment(){
    highp vec2 pixelSize = vec2(1.0/SCREEN_PIXEL_SIZE.x, 1.0/SCREEN_PIXEL_SIZE.y);
    highp vec4 color = texture(SCREEN_TEXTURE, UV);

    // --- This is the new mechanic for calculating the effect mask ---
    highp float mask = 1.0;

    // IgnoreRadius pass
    // radial is 1 inside the safe circle, 0 outside.
    highp float radial = zCircleGradient(pixelSize, FRAGCOORD.xy, 1.0, (ConeIgnoreFeather) / 1.0, (ConeIgnoreRadius / pow(ConeIgnoreFeather, 0.85)) / Zoom, 1.0);
    mask -= radial;

    // Setup for cone pass
    highp vec2 delta = FRAGCOORD.xy - (pixelSize * 0.5);
    highp float deltaAngle = atan(delta.x, delta.y);
    deltaAngle += ViewAngle;
    deltaAngle = mod(deltaAngle, radians(360.0));
    deltaAngle = abs(radians(180.0) - mod(deltaAngle, radians(360.0)));

    // The pass that actually renders the cone
    highp float radAngle = radians(ConeAngle);
    highp float radFeather = radians(ConeFeather) + pow(1.0 - radial, 2.0);
    // deltaAngle becomes the cone visibility factor (1 inside, 0 outside)
    deltaAngle = 1.0 - clamp((deltaAngle - (radAngle * 0.5)) + (radFeather * 0.5), 0.0, radFeather) / radFeather;
    mask += clamp(deltaAngle, 0.0, 1.0);

    // The final mask: 1.0 means full effect (out of view), 0.0 means no effect (in view).
    mask = 1.0 - clamp(mask, 0.0, 1.0);

    mediump vec4 blurredColor = texture(BLURRED_TEXTURE, UV);
    // Mix blurred color with black based on opacity to create the "out of FOV" color
    mediump vec4 outOfFovColor = mix(blurredColor, vec4(0.0, 0.0, 0.0, 1.0), coneOpacity);

    // Mix the original screen color with the "out of FOV" color using the calculated mask
    COLOR = vec4(mix(color.rgb, outOfFovColor.rgb, mask), color.a);
}
